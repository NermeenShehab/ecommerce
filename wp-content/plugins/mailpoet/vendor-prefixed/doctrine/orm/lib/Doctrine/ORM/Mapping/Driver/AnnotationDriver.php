<?php
 namespace MailPoetVendor\Doctrine\ORM\Mapping\Driver; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\Common\Annotations\AnnotationReader; use MailPoetVendor\Doctrine\ORM\Events; use MailPoetVendor\Doctrine\ORM\Id\TableGenerator; use MailPoetVendor\Doctrine\ORM\Mapping; use MailPoetVendor\Doctrine\ORM\Mapping\Builder\EntityListenerBuilder; use MailPoetVendor\Doctrine\ORM\Mapping\MappingException; use MailPoetVendor\Doctrine\Persistence\Mapping\ClassMetadata; use MailPoetVendor\Doctrine\Persistence\Mapping\Driver\AnnotationDriver as AbstractAnnotationDriver; use ReflectionClass; use ReflectionMethod; use ReflectionProperty; use UnexpectedValueException; use function class_exists; use function constant; use function count; use function defined; use function get_class; use function is_array; use function is_numeric; class AnnotationDriver extends \MailPoetVendor\Doctrine\Persistence\Mapping\Driver\AnnotationDriver { protected $entityAnnotationClasses = [\MailPoetVendor\Doctrine\ORM\Mapping\Entity::class => 1, \MailPoetVendor\Doctrine\ORM\Mapping\MappedSuperclass::class => 2]; public function loadMetadataForClass($className, \MailPoetVendor\Doctrine\Persistence\Mapping\ClassMetadata $metadata) { $class = $metadata->getReflectionClass(); if (!$class) { $class = new \ReflectionClass($metadata->name); } $classAnnotations = $this->reader->getClassAnnotations($class); if ($classAnnotations) { foreach ($classAnnotations as $key => $annot) { if (!\is_numeric($key)) { continue; } $classAnnotations[\get_class($annot)] = $annot; } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Entity::class])) { $entityAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Entity::class]; if ($entityAnnot->repositoryClass !== null) { $metadata->setCustomRepositoryClass($entityAnnot->repositoryClass); } if ($entityAnnot->readOnly) { $metadata->markReadOnly(); } } elseif (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\MappedSuperclass::class])) { $mappedSuperclassAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\MappedSuperclass::class]; $metadata->setCustomRepositoryClass($mappedSuperclassAnnot->repositoryClass); $metadata->isMappedSuperclass = \true; } elseif (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Embeddable::class])) { $metadata->isEmbeddedClass = \true; } else { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::classIsNotAValidEntityOrMappedSuperClass($className); } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Table::class])) { $tableAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Table::class]; $primaryTable = ['name' => $tableAnnot->name, 'schema' => $tableAnnot->schema]; if ($tableAnnot->indexes !== null) { foreach ($tableAnnot->indexes as $indexAnnot) { $index = []; if (!empty($indexAnnot->columns)) { $index['columns'] = $indexAnnot->columns; } if (!empty($indexAnnot->fields)) { $index['fields'] = $indexAnnot->fields; } if (isset($index['columns'], $index['fields']) || !isset($index['columns']) && !isset($index['fields'])) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::invalidIndexConfiguration($className, (string) ($indexAnnot->name ?? \count($primaryTable['indexes']))); } if (!empty($indexAnnot->flags)) { $index['flags'] = $indexAnnot->flags; } if (!empty($indexAnnot->options)) { $index['options'] = $indexAnnot->options; } if (!empty($indexAnnot->name)) { $primaryTable['indexes'][$indexAnnot->name] = $index; } else { $primaryTable['indexes'][] = $index; } } } if ($tableAnnot->uniqueConstraints !== null) { foreach ($tableAnnot->uniqueConstraints as $uniqueConstraintAnnot) { $uniqueConstraint = []; if (!empty($uniqueConstraintAnnot->columns)) { $uniqueConstraint['columns'] = $uniqueConstraintAnnot->columns; } if (!empty($uniqueConstraintAnnot->fields)) { $uniqueConstraint['fields'] = $uniqueConstraintAnnot->fields; } if (isset($uniqueConstraint['columns'], $uniqueConstraint['fields']) || !isset($uniqueConstraint['columns']) && !isset($uniqueConstraint['fields'])) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::invalidUniqueConstraintConfiguration($className, (string) ($uniqueConstraintAnnot->name ?? \count($primaryTable['uniqueConstraints']))); } if (!empty($uniqueConstraintAnnot->options)) { $uniqueConstraint['options'] = $uniqueConstraintAnnot->options; } if (!empty($uniqueConstraintAnnot->name)) { $primaryTable['uniqueConstraints'][$uniqueConstraintAnnot->name] = $uniqueConstraint; } else { $primaryTable['uniqueConstraints'][] = $uniqueConstraint; } } } if ($tableAnnot->options) { $primaryTable['options'] = $tableAnnot->options; } $metadata->setPrimaryTable($primaryTable); } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Cache::class])) { $cacheAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Cache::class]; $cacheMap = ['region' => $cacheAnnot->region, 'usage' => (int) \constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::CACHE_USAGE_' . $cacheAnnot->usage)]; $metadata->enableCache($cacheMap); } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\NamedNativeQueries::class])) { $namedNativeQueriesAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\NamedNativeQueries::class]; foreach ($namedNativeQueriesAnnot->value as $namedNativeQuery) { $metadata->addNamedNativeQuery(['name' => $namedNativeQuery->name, 'query' => $namedNativeQuery->query, 'resultClass' => $namedNativeQuery->resultClass, 'resultSetMapping' => $namedNativeQuery->resultSetMapping]); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\SqlResultSetMappings::class])) { $sqlResultSetMappingsAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\SqlResultSetMappings::class]; foreach ($sqlResultSetMappingsAnnot->value as $resultSetMapping) { $entities = []; $columns = []; foreach ($resultSetMapping->entities as $entityResultAnnot) { $entityResult = ['fields' => [], 'entityClass' => $entityResultAnnot->entityClass, 'discriminatorColumn' => $entityResultAnnot->discriminatorColumn]; foreach ($entityResultAnnot->fields as $fieldResultAnnot) { $entityResult['fields'][] = ['name' => $fieldResultAnnot->name, 'column' => $fieldResultAnnot->column]; } $entities[] = $entityResult; } foreach ($resultSetMapping->columns as $columnResultAnnot) { $columns[] = ['name' => $columnResultAnnot->name]; } $metadata->addSqlResultSetMapping(['name' => $resultSetMapping->name, 'entities' => $entities, 'columns' => $columns]); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\NamedQueries::class])) { $namedQueriesAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\NamedQueries::class]; if (!\is_array($namedQueriesAnnot->value)) { throw new \UnexpectedValueException('@NamedQueries should contain an array of @NamedQuery annotations.'); } foreach ($namedQueriesAnnot->value as $namedQuery) { if (!$namedQuery instanceof \MailPoetVendor\Doctrine\ORM\Mapping\NamedQuery) { throw new \UnexpectedValueException('@NamedQueries should contain an array of @NamedQuery annotations.'); } $metadata->addNamedQuery(['name' => $namedQuery->name, 'query' => $namedQuery->query]); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\InheritanceType::class])) { $inheritanceTypeAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\InheritanceType::class]; $metadata->setInheritanceType(\constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::INHERITANCE_TYPE_' . $inheritanceTypeAnnot->value)); if ($metadata->inheritanceType !== \MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata::INHERITANCE_TYPE_NONE) { if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\DiscriminatorColumn::class])) { $discrColumnAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\DiscriminatorColumn::class]; $metadata->setDiscriminatorColumn(['name' => $discrColumnAnnot->name, 'type' => $discrColumnAnnot->type ?: 'string', 'length' => $discrColumnAnnot->length ?: 255, 'columnDefinition' => $discrColumnAnnot->columnDefinition]); } else { $metadata->setDiscriminatorColumn(['name' => 'dtype', 'type' => 'string', 'length' => 255]); } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\DiscriminatorMap::class])) { $discrMapAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\DiscriminatorMap::class]; $metadata->setDiscriminatorMap($discrMapAnnot->value); } } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\ChangeTrackingPolicy::class])) { $changeTrackingAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\ChangeTrackingPolicy::class]; $metadata->setChangeTrackingPolicy(\constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::CHANGETRACKING_' . $changeTrackingAnnot->value)); } foreach ($class->getProperties() as $property) { if ($metadata->isMappedSuperclass && !$property->isPrivate() || $metadata->isInheritedField($property->name) || $metadata->isInheritedAssociation($property->name) || $metadata->isInheritedEmbeddedClass($property->name)) { continue; } $mapping = []; $mapping['fieldName'] = $property->getName(); $cacheAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Cache::class); if ($cacheAnnot !== null) { $mapping['cache'] = $metadata->getAssociationCacheDefaults($mapping['fieldName'], ['usage' => (int) \constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::CACHE_USAGE_' . $cacheAnnot->usage), 'region' => $cacheAnnot->region]); } $joinColumns = []; $joinColumnAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\JoinColumn::class); if ($joinColumnAnnot) { $joinColumns[] = $this->joinColumnToArray($joinColumnAnnot); } else { $joinColumnsAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\JoinColumns::class); if ($joinColumnsAnnot) { foreach ($joinColumnsAnnot->value as $joinColumn) { $joinColumns[] = $this->joinColumnToArray($joinColumn); } } } $columnAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Column::class); if ($columnAnnot) { $mapping = $this->columnToArray($property->getName(), $columnAnnot); $idAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Id::class); if ($idAnnot) { $mapping['id'] = \true; } $generatedValueAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\GeneratedValue::class); if ($generatedValueAnnot) { $metadata->setIdGeneratorType(\constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::GENERATOR_TYPE_' . $generatedValueAnnot->strategy)); } if ($this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Version::class)) { $metadata->setVersionMapping($mapping); } $metadata->mapField($mapping); $seqGeneratorAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\SequenceGenerator::class); if ($seqGeneratorAnnot) { $metadata->setSequenceGeneratorDefinition(['sequenceName' => $seqGeneratorAnnot->sequenceName, 'allocationSize' => $seqGeneratorAnnot->allocationSize, 'initialValue' => $seqGeneratorAnnot->initialValue]); } elseif ($this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Id\TableGenerator::class)) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::tableIdGeneratorNotImplemented($className); } else { $customGeneratorAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\CustomIdGenerator::class); if ($customGeneratorAnnot) { $metadata->setCustomGeneratorDefinition(['class' => $customGeneratorAnnot->class]); } } } else { $this->loadRelationShipMapping($property, $mapping, $metadata, $joinColumns, $className); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\AssociationOverrides::class])) { $associationOverridesAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\AssociationOverrides::class]; foreach ($associationOverridesAnnot->value as $associationOverride) { $override = []; $fieldName = $associationOverride->name; if ($associationOverride->joinColumns) { $joinColumns = []; foreach ($associationOverride->joinColumns as $joinColumn) { $joinColumns[] = $this->joinColumnToArray($joinColumn); } $override['joinColumns'] = $joinColumns; } if ($associationOverride->joinTable) { $joinTableAnnot = $associationOverride->joinTable; $joinTable = ['name' => $joinTableAnnot->name, 'schema' => $joinTableAnnot->schema]; foreach ($joinTableAnnot->joinColumns as $joinColumn) { $joinTable['joinColumns'][] = $this->joinColumnToArray($joinColumn); } foreach ($joinTableAnnot->inverseJoinColumns as $joinColumn) { $joinTable['inverseJoinColumns'][] = $this->joinColumnToArray($joinColumn); } $override['joinTable'] = $joinTable; } if ($associationOverride->inversedBy) { $override['inversedBy'] = $associationOverride->inversedBy; } if ($associationOverride->fetch) { $override['fetch'] = \constant(\MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata::class . '::FETCH_' . $associationOverride->fetch); } $metadata->setAssociationOverride($fieldName, $override); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\AttributeOverrides::class])) { $attributeOverridesAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\AttributeOverrides::class]; foreach ($attributeOverridesAnnot->value as $attributeOverrideAnnot) { $attributeOverride = $this->columnToArray($attributeOverrideAnnot->name, $attributeOverrideAnnot->column); $metadata->setAttributeOverride($attributeOverrideAnnot->name, $attributeOverride); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\EntityListeners::class])) { $entityListenersAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\EntityListeners::class]; foreach ($entityListenersAnnot->value as $item) { $listenerClassName = $metadata->fullyQualifiedClassName($item); if (!\class_exists($listenerClassName)) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::entityListenerClassNotFound($listenerClassName, $className); } $hasMapping = \false; $listenerClass = new \ReflectionClass($listenerClassName); foreach ($listenerClass->getMethods(\ReflectionMethod::IS_PUBLIC) as $method) { $callbacks = $this->getMethodCallbacks($method); $hasMapping = $hasMapping ?: !empty($callbacks); foreach ($callbacks as $value) { $metadata->addEntityListener($value[1], $listenerClassName, $value[0]); } } if (!$hasMapping) { \MailPoetVendor\Doctrine\ORM\Mapping\Builder\EntityListenerBuilder::bindEntityListener($metadata, $listenerClassName); } } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\HasLifecycleCallbacks::class])) { foreach ($class->getMethods(\ReflectionMethod::IS_PUBLIC) as $method) { foreach ($this->getMethodCallbacks($method) as $value) { $metadata->addLifecycleCallback($value[0], $value[1]); } } } } private function loadRelationShipMapping(\ReflectionProperty $property, array &$mapping, \MailPoetVendor\Doctrine\Persistence\Mapping\ClassMetadata $metadata, array $joinColumns, string $className) : void { $oneToOneAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\OneToOne::class); if ($oneToOneAnnot) { $idAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Id::class); if ($idAnnot) { $mapping['id'] = \true; } $mapping['targetEntity'] = $oneToOneAnnot->targetEntity; $mapping['joinColumns'] = $joinColumns; $mapping['mappedBy'] = $oneToOneAnnot->mappedBy; $mapping['inversedBy'] = $oneToOneAnnot->inversedBy; $mapping['cascade'] = $oneToOneAnnot->cascade; $mapping['orphanRemoval'] = $oneToOneAnnot->orphanRemoval; $mapping['fetch'] = $this->getFetchMode($className, $oneToOneAnnot->fetch); $metadata->mapOneToOne($mapping); return; } $oneToManyAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\OneToMany::class); if ($oneToManyAnnot) { $mapping['mappedBy'] = $oneToManyAnnot->mappedBy; $mapping['targetEntity'] = $oneToManyAnnot->targetEntity; $mapping['cascade'] = $oneToManyAnnot->cascade; $mapping['indexBy'] = $oneToManyAnnot->indexBy; $mapping['orphanRemoval'] = $oneToManyAnnot->orphanRemoval; $mapping['fetch'] = $this->getFetchMode($className, $oneToManyAnnot->fetch); $orderByAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\OrderBy::class); if ($orderByAnnot) { $mapping['orderBy'] = $orderByAnnot->value; } $metadata->mapOneToMany($mapping); } $manyToOneAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\ManyToOne::class); if ($manyToOneAnnot) { $idAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Id::class); if ($idAnnot) { $mapping['id'] = \true; } $mapping['joinColumns'] = $joinColumns; $mapping['cascade'] = $manyToOneAnnot->cascade; $mapping['inversedBy'] = $manyToOneAnnot->inversedBy; $mapping['targetEntity'] = $manyToOneAnnot->targetEntity; $mapping['fetch'] = $this->getFetchMode($className, $manyToOneAnnot->fetch); $metadata->mapManyToOne($mapping); } $manyToManyAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\ManyToMany::class); if ($manyToManyAnnot) { $joinTable = []; $joinTableAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\JoinTable::class); if ($joinTableAnnot) { $joinTable = ['name' => $joinTableAnnot->name, 'schema' => $joinTableAnnot->schema]; foreach ($joinTableAnnot->joinColumns as $joinColumn) { $joinTable['joinColumns'][] = $this->joinColumnToArray($joinColumn); } foreach ($joinTableAnnot->inverseJoinColumns as $joinColumn) { $joinTable['inverseJoinColumns'][] = $this->joinColumnToArray($joinColumn); } } $mapping['joinTable'] = $joinTable; $mapping['targetEntity'] = $manyToManyAnnot->targetEntity; $mapping['mappedBy'] = $manyToManyAnnot->mappedBy; $mapping['inversedBy'] = $manyToManyAnnot->inversedBy; $mapping['cascade'] = $manyToManyAnnot->cascade; $mapping['indexBy'] = $manyToManyAnnot->indexBy; $mapping['orphanRemoval'] = $manyToManyAnnot->orphanRemoval; $mapping['fetch'] = $this->getFetchMode($className, $manyToManyAnnot->fetch); $orderByAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\OrderBy::class); if ($orderByAnnot) { $mapping['orderBy'] = $orderByAnnot->value; } $metadata->mapManyToMany($mapping); } $embeddedAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Embedded::class); if ($embeddedAnnot) { $mapping['class'] = $embeddedAnnot->class; $mapping['columnPrefix'] = $embeddedAnnot->columnPrefix; $metadata->mapEmbedded($mapping); } } private function getFetchMode(string $className, string $fetchMode) : int { if (!\defined('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::FETCH_' . $fetchMode)) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::invalidFetchMode($className, $fetchMode); } return \constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::FETCH_' . $fetchMode); } private function getMethodCallbacks(\ReflectionMethod $method) : array { $callbacks = []; $annotations = $this->reader->getMethodAnnotations($method); foreach ($annotations as $annot) { if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PrePersist) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::prePersist]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PostPersist) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::postPersist]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PreUpdate) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::preUpdate]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PostUpdate) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::postUpdate]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PreRemove) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::preRemove]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PostRemove) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::postRemove]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PostLoad) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::postLoad]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PreFlush) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::preFlush]; } } return $callbacks; } private function joinColumnToArray(\MailPoetVendor\Doctrine\ORM\Mapping\JoinColumn $joinColumn) : array { return ['name' => $joinColumn->name, 'unique' => $joinColumn->unique, 'nullable' => $joinColumn->nullable, 'onDelete' => $joinColumn->onDelete, 'columnDefinition' => $joinColumn->columnDefinition, 'referencedColumnName' => $joinColumn->referencedColumnName]; } private function columnToArray(string $fieldName, \MailPoetVendor\Doctrine\ORM\Mapping\Column $column) : array { $mapping = ['fieldName' => $fieldName, 'type' => $column->type, 'scale' => $column->scale, 'length' => $column->length, 'unique' => $column->unique, 'nullable' => $column->nullable, 'precision' => $column->precision]; if ($column->options) { $mapping['options'] = $column->options; } if (isset($column->name)) { $mapping['columnName'] = $column->name; } if (isset($column->columnDefinition)) { $mapping['columnDefinition'] = $column->columnDefinition; } return $mapping; } public static function create($paths = [], ?\MailPoetVendor\Doctrine\Common\Annotations\AnnotationReader $reader = null) { if ($reader === null) { $reader = new \MailPoetVendor\Doctrine\Common\Annotations\AnnotationReader(); } return new self($reader, $paths); } } 